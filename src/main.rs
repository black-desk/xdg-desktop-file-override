use clap::Command;
use regex::Regex;
use serde::Deserialize;
use std::env;
use std::fs::File;
use std::io::{self, Write};
use std::path::PathBuf;
use std::process::{Command as ProcessCommand, Stdio};

#[derive(Debug, Deserialize)]
struct Config {
    version: String,
    generators: Vec<Generator>,
}

#[derive(Debug, Deserialize)]
struct Generator {
    filter: String,
    name: String,
    command: Vec<String>,
}

const CONFIG_FILE_PATH: &str = "xdg-desktop-file-override/config.yaml";

fn main() -> io::Result<()> {
    let version = "0.1.0";
    let matches = Command::new("xdg-desktop-file-override")
        .version(version)
        .author("Author Name <author@example.com>")
        .about("Generate new desktop file to XDG_DATA_HOME/applications according to configuration.")
        .arg(clap::Arg::new("debug").short('d').long("debug").help("Print debug information verbosely").num_args(0).required(false))
        .long_about("xdg-desktop-file-override read a configuration file
at XDG_CONFIG_DIRS/xdg-desktop-file-override/config.yaml
and generate new desktop file from existing desktop files to XDG_DATA_HOME/applications
according to that configuration file.

As the desktop entry specification says,
these new .desktop files will override the old one provided by system or packager.

> If multiple files have the same desktop file ID,
> the first one in the $XDG_DATA_DIRS precedence order is used.

In detail, xdg-desktop-file-override will
go through activate desktop files one by one
and try pipe its content into generator command
if the file name of desktop file matched the regex filter.
If the generator return non-zero exit code,
the generator will be ignored,
else the stdout of generator will be treated as new desktop file content
and pipe to other generators
until all generators are processed,
then the new desktop file will be written to XDG_DATA_HOME/application with an extra property
X-XDG-Desktop-File-Override-Version=<version>.
This program will not overwrite existing file in XDG_DATA_HOME which is not generated by xdg-desktop-file-override.

It can be use to:
1. Customize the command used to run some desktop application;
2. Fix application with wrong StartupWMClass/StartupNotify property;
4. Add new MimeType to open some file type with the application.

The configuration file is a yaml file looks like this::

```yaml
version: 0.1.0
generators:
  - name: remove-all-dbusactivatable-equals-true
    filter: .*
    command: [ 'sed',
      '-e', 's/DBusActivatable=true/d',
    ]
  - filter: ^zed\\.desktop$
    name: fix-zeditor
    command: [ 'sed',
      # Add missing StartupWMClass
      '-e', '/\\[Desktop Entry\\]/a StartupWMClass=dev.zed.Zed',
      # Remove StartupNotify
      '-e', '/StartupNotify=true/d',
    ]
```")
        .subcommand(Command::new("clean").about("Remove the generated desktop files"))
        .get_matches();

    if let Some(_matches) = matches.subcommand_matches("clean") {
        clean_generated_files()?;
        return Ok(());
    }

    let debug = matches.get_one::<bool>("debug").unwrap();

    // Read configuration file
    let config_path = get_config_path()?;
    if *debug {
        println!("Using configuration file at: {:?}", config_path);
    }
    let config_file = File::open(config_path)?;
    let config: Config = serde_yaml::from_reader(config_file)
        .map_err(|e| io::Error::new(io::ErrorKind::Other, e.to_string()))?;

    if *debug {
        // Print the version from the configuration file
        println!("Config version: {}", config.version);
    }

    // Get desktop files from XDG_DATA_DIRS
    let desktop_files = get_desktop_files()?;

    // Process each desktop file
    for desktop_file in desktop_files {
        let content = std::fs::read_to_string(&desktop_file)?;
        let mut new_content = content.clone();
        let mut updated = false;

        for generator in &config.generators {
            let re = Regex::new(&generator.filter).unwrap();
            if !re.is_match(desktop_file.file_name().unwrap().to_str().unwrap()) {
                continue;
            }

            if *debug {
                // Print the name of the generator
                println!(
                    "Applying generator {} on {}",
                    generator.name,
                    desktop_file.display(),
                );
            }

            let output = apply_generator(&generator.command, &new_content)?;
            if output.status.success() {
                let generated_content = String::from_utf8_lossy(&output.stdout).to_string();
                if generated_content != new_content {
                    new_content = generated_content;
                    updated = true;
                }
            }
        }

        if updated {
            // Write new content to XDG_DATA_HOME/applications
            write_new_desktop_file(&desktop_file, &new_content)?;
        }
    }

    Ok(())
}

fn get_config_path() -> io::Result<PathBuf> {
    // Check XDG_CONFIG_HOME
    let xdg_config_home = env::var("XDG_CONFIG_HOME").unwrap_or_else(|_| {
        let home = env::var("HOME").expect("HOME environment variable not set");
        format!("{}/.config", home)
    });
    let config_path = PathBuf::from(xdg_config_home).join(CONFIG_FILE_PATH);
    if config_path.exists() {
        return Ok(config_path);
    }

    // Check XDG_CONFIG_DIRS
    let xdg_config_dirs = env::var("XDG_CONFIG_DIRS").unwrap_or_else(|_| "/etc/xdg".to_string());
    let paths: Vec<PathBuf> = env::split_paths(&xdg_config_dirs).collect();
    for path in paths {
        let config_path = path.join(CONFIG_FILE_PATH);
        if config_path.exists() {
            return Ok(config_path);
        }
    }

    // Check default config path
    let default_config_path = PathBuf::from("/etc/xdg").join(CONFIG_FILE_PATH);
    if default_config_path.exists() {
        return Ok(default_config_path);
    }

    Err(io::Error::new(
        io::ErrorKind::NotFound,
        "Configuration file not found",
    ))
}

fn get_desktop_files() -> io::Result<Vec<PathBuf>> {
    let xdg_data_dirs =
        env::var("XDG_DATA_DIRS").unwrap_or_else(|_| "/usr/local/share:/usr/share".to_string());
    let paths: Vec<PathBuf> = env::split_paths(&xdg_data_dirs).collect();
    let mut desktop_files = Vec::new();

    for path in paths {
        let applications_path = path.join("applications");
        if !applications_path.exists() {
            continue;
        }

        for entry in std::fs::read_dir(applications_path)? {
            let entry = entry?;
            if entry.path().extension().and_then(|s| s.to_str()) == Some("desktop") {
                desktop_files.push(entry.path());
            }
        }
    }

    Ok(desktop_files)
}

fn apply_generator(command: &[String], input: &str) -> io::Result<std::process::Output> {
    let mut cmd = ProcessCommand::new(&command[0]);
    cmd.args(&command[1..])
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = cmd.spawn()?;
    {
        let stdin = child
            .stdin
            .as_mut()
            .ok_or_else(|| io::Error::new(io::ErrorKind::Other, "Failed to open stdin"))?;
        stdin.write_all(input.as_bytes())?;
    }

    let output = child.wait_with_output()?;
    Ok(output)
}

fn write_new_desktop_file(original_path: &PathBuf, content: &str) -> io::Result<()> {
    println!(
        "Writing new desktop file {:?}",
        original_path.file_name().unwrap()
    );

    let xdg_data_home = env::var("XDG_DATA_HOME")
        .unwrap_or_else(|_| format!("{}/.local/share", env::var("HOME").unwrap()));
    let new_path = PathBuf::from(xdg_data_home)
        .join("applications")
        .join(original_path.file_name().unwrap());

    let mut final_content = content.to_string();
    let override_property = "X-XDG-Desktop-File-Override-Version";
    if !final_content.contains(override_property) {
        // Insert the property into the beginning of the main section
        let main_section_start =
            final_content.find("[Desktop Entry]").unwrap_or_else(|| 0) + "[Desktop Entry]".len();
        final_content.insert_str(
            main_section_start,
            &format!("\n{}={}", override_property, "0.1.0"),
        );
    }

    if new_path.exists() {
        let existing_content = std::fs::read_to_string(&new_path)?;
        if existing_content.contains(override_property) {
            return std::fs::write(new_path, final_content);
        }
    } else {
        return std::fs::write(new_path, final_content);
    }

    Ok(())
}

fn clean_generated_files() -> io::Result<()> {
    let xdg_data_home = env::var("XDG_DATA_HOME")
        .unwrap_or_else(|_| format!("{}/.local/share", env::var("HOME").unwrap()));
    let applications_path = PathBuf::from(xdg_data_home).join("applications");

    for entry in std::fs::read_dir(applications_path)? {
        let entry = entry?;
        if entry.path().extension().and_then(|s| s.to_str()) == Some("desktop") {
            let content = std::fs::read_to_string(&entry.path())?;
            if content.contains("X-XDG-Desktop-File-Override-Version") {
                std::fs::remove_file(entry.path())?;
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::{self, File};
    use tempfile::tempdir;

    #[test]
    fn test_get_config_path() {
        let dir = tempdir().unwrap();
        let config_path = dir.path().join("xdg-desktop-file-override/config.yaml");
        fs::create_dir_all(config_path.parent().unwrap()).unwrap();
        File::create(&config_path).unwrap();

        env::set_var("XDG_CONFIG_HOME", dir.path().to_str().unwrap());
        let result = get_config_path().unwrap();
        assert_eq!(result, config_path);
    }

    #[test]
    fn test_get_desktop_files() {
        let dir = tempdir().unwrap();
        let applications_path = dir.path().join("applications");
        fs::create_dir_all(&applications_path).unwrap();
        File::create(applications_path.join("test.desktop")).unwrap();

        env::set_var("XDG_DATA_DIRS", dir.path().to_str().unwrap());
        let result = get_desktop_files().unwrap();
        assert_eq!(result.len(), 1);
        assert_eq!(result[0].file_name().unwrap(), "test.desktop");
    }

    #[test]
    fn test_apply_generator() {
        let command = vec![
            "sed".to_string(),
            "-e".to_string(),
            "s/foo/bar/".to_string(),
        ];
        let input = "foo";
        let output = apply_generator(&command, input).unwrap();
        let result = String::from_utf8_lossy(&output.stdout);
        assert_eq!(result, "bar");
    }

    #[test]
    fn test_write_new_desktop_file() {
        let dir = tempdir().unwrap();
        let applications_path = dir.path().join("applications");
        fs::create_dir_all(&applications_path).unwrap();
        let original_path = applications_path.join("test.desktop");
        let content = "[Desktop Entry]\nName=Test";

        env::set_var("XDG_DATA_HOME", dir.path().to_str().unwrap());
        write_new_desktop_file(&original_path, content).unwrap();

        let new_path = applications_path.join("test.desktop");
        let result = fs::read_to_string(new_path).unwrap();
        assert!(result.contains("X-XDG-Desktop-File-Override-Version=0.1.0"));
    }
}
